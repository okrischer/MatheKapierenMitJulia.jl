---
title: "Zahlen und Zahlensysteme"
---

## Nat√ºrliche Zahlen

Die [nat√ºrliche Zahlen](https://de.wikipedia.org/wiki/Nat%C3%BCrliche_Zahl) sind die grundlegenden Zahlen, die wir zum Z√§hlen benutzen.
Die Menge der nat√ºrlichen Zahlen wird mit dem Symbol $\mathbb{N}$ bezeichnet und umfasst in der traditionellen Darstellung alle positiven ganzen Zahlen, also

$$
\mathbb{N} = \{1,2,3\dots\}
$$

Diese Darstellung hat sich aber als unzureichend herausgestellt, auch weil die [ganzen Zahlen](https://de.wikipedia.org/wiki/Z%C3%A4hlen) selbst als Erweiterung der nat√ºrlichen Zahlen definiert sind, und die obige Definition damit eigentlich nichts aussagt (vgl. hierzu [Selbstreferenzialit√§t](https://de.wikipedia.org/wiki/Selbstreferenzialit%C3%A4t)).

Ende des 19. Jarhunderts wurde diese Definition durch ein formal pr√§zises System, den
sogenannten [Peano-Axiomen](https://de.wikipedia.org/wiki/Peano-Axiome) abgel√∂st, benannt nach dem italienischen Mathematiker [Guiseppe Peano](https://de.wikipedia.org/wiki/Giuseppe_Peano).
Die Menge der nat√ºrlichen Zahlen ist danach die Menge der Zahlen, die den *Peano-Axiomen* gen√ºgt.

::: {.callout-important}
## Peano-Axiome
Die mengentheoretischen und logischen Grundlagen der *Peano-Axiome* sollen uns an dieser Stelle nicht interessieren.
F√ºr uns gen√ºgt es, die nachfolgenden Grunds√§tze zu verstehen:

Die `0` ist eine nat√ºrliche Zahl, hat aber eine Sonderrolle: sie hat als einzige nat√ºrliche Zahl keinen Vorg√§nger und ist damit das kleinste Element der Menge.

Alle nat√ºrlichen Zahlen haben einen direkten Nachfolger, dessen Wert jeweils um `1` gr√∂√üer ist.
Damit kann auch f√ºr jede Zahl mit Ausnahme der `0` ein eindeutiger Vorg√§nger bestimmt werden.
Es ergeben sich folgende Definitionen f√ºr den Nachfolger `n'` und den Vorg√§nger einer Zahl `n`:

$$
\begin{align*}
n' &= n + 1 \\
n &= n' - 1, \quad n' > 0
\end{align*}
$$
:::

Wir wollen im Folgenden zeigen, dass diese Definitionen reichen, um alle vier [Grundrechenarten](https://de.wikipedia.org/wiki/Grundrechenart) *Addition*, *Subtraktion*, *Multiplikation* und *Division* abzubilden.
Das bedeutet, dass die Grundrechenarten letzlich auf einfaches *Z√§hlen* zur√ºckgef√ºhrt werden k√∂nnen.

### Z√§hlen

[Z√§hlen](https://de.wikipedia.org/wiki/Z%C3%A4hlen) dient der Ermittlung der Anzahl der Elemente einer endlichen Menge von Objekten gleicher Art.
In Julia k√∂nnen wir mit den obigen Definitionen f√ºr den *Nachfolger* und *Vorg√§nger* einer nat√ºrlichen Zahl so z√§hlen:

```{julia}
n = 0
n += 1
@show n
n -= 1
@show n;
```

Der Ausdruck `n += 1` ist eine k√ºrzere Schreibweise f√ºr `n = n + 1`, der einer Variablen `n` einen um `1` h√∂heren Wert zuweist (vorw√§rts z√§hlen).
Genauso bedeutet `n -= 1`, der Variablen `n` einen um `1` niedrigeren Wert zuzuweisen (r√ºckw√§rts z√§hlen).

Nehmen wir an, wir haben zwei Obstschalen, eine mit √Ñpfeln und eine mit Birnen:

```{julia}
apfel = "üçé"
√§pfel = [apfel, apfel, apfel, apfel]
birne = "üçê"
birnen = [birne, birne, birne]
@show √§pfel
@show birnen;
```

Um die Anzahl der Fr√ºchte in den jeweiligen Schalen zu bestimmen, erstellen wir eine [Funktion](https://docs.julialang.org/en/v1/manual/functions/), die elementares Z√§hlen simuliert:

```{julia}
function count(collection::AbstractVector)
  n = 0
  for e in collection
    n += 1
  end
  n
end
```

Das *Z√§hlen* wird in einer [for-Schleife](https://docs.julialang.org/en/v1/manual/control-flow/#man-loops) simuliert, in der f√ºr jedes Element einer *collection* der Z√§hler `n` um `1` erh√∂ht wird.

::: {.callout-note}
## Datentyp Vector
Ein [Vector](https://docs.julialang.org/en/v1/base/arrays/#Base.Vector) in Julia ist eine Sammlung (engl. *collection*) von Objekten eines bestimmten Datentyps.

Um genau zu sein, ist eine Sammlung nicht das Gleiche wie eine Menge.
Eine Sammlung ist immer endlich und kann ein bestimmtes Objekt mehrfach enthalten.
Das ist f√ºr unsere √úberlegungen hier aber unerheblich; wir verwenden "Sammlung" als Synonym f√ºr "Menge".

Der Parameter `collection` der Funktion `count` ist als `AbstractVector` festgelegt, ein *abstrakter Datentyp*, der es erlaubt, an dieser Stelle einen Vector eines beliebigen Datentyps zu √ºbergeben.
Die oben definierten Vectoren `√§pfel` und `birnen` sind z.B. vom Typ `Vector{String}`.
:::

Wir k√∂nnen damit beliebige endliche Mengen abz√§hlen, wobei es keine Rolle spielt, welche Objekte gez√§hlt werden. Das Ergebnis ist immer eine nat√ºrliche Zahl:

```{julia}
@show count(√§pfel)
@show count(birnen);
```

### Addition

Was w√ºrde ein Kind machen, das noch nicht Rechnen gelernt hat, um die Gesamtzahl der Fr√ºchte zu bestimmen, d.h. die Anzahl der √Ñpfel und Birnen zu *addieren*?
Vielleicht w√ºrde es so vorgehen:

::: {.callout-note}
## Addieren mit Abz√§hlen: Zusammenz√§hlen

1. Die √Ñpfel aus der ersten Schale z√§hlen und sich das Ergebnis merken: `vier`.
2. Die Birnen nacheinander aus der zweiten Schale nehmen, zu den √Ñpfeln legen und dabei weiterz√§hlen: `f√ºnf`, `sechs`, `sieben`.
3. Wenn alle Birnen bei den √Ñpfeln liegen ist der Vorgang abgeschlossen und das Ergebnis ist das letzte Zahlwort: `sieben`.
:::

Wir haben damit gerade unseren ersten [Algorithmus](https://de.wikipedia.org/wiki/Algorithmus) definiert: eine Anweisung zum *Zusammenz√§hlen* zweier Mengen.
Der Algorithmus kann so in Julia implementiert werden:

```{julia}
function count_up(a::AbstractVector, b::AbstractVector)
  n = count(a)                                              # <1>
  while !isempty(b)
    push!(a, pop!(b))                                       # <2>
    n += 1
  end
  (n, a)                                                    # <3>
end
```

1. Abz√§hlen der Elemente aus der ersten Menge **a**.
2. Ein Element aus der zweiten Menge **b** mit [pop!](https://docs.julialang.org/en/v1/base/collections/#Base.pop!) entnehmen und mit [push!](https://docs.julialang.org/en/v1/base/collections/#Base.push!) zur ersten Menge **a** hinzuf√ºgen; dann mit **n += 1** weiterz√§hlen.
3. Wenn die Schleife beendet ist (**b** ist jetzt leer), werden der Z√§hler **n** und die erste Menge **a** als Ergebnis zur√ºck gegeben.

Wir pr√ºfen, ob der Algorithmus wie beabsichtigt funktioniert:

```{julia}
n, fr√ºchte = count_up(√§pfel, birnen)
@show fr√ºchte
@assert n == 4 + 3
```

Das Macro [@assert](https://docs.julialang.org/en/v1/base/base/#Base.@assert) pr√ºft, ob die Gesamtzahl der Fr√ºchte `n` tats√§chlich gleich der Summe von `4` und `3` ist.
Wenn nicht, w√ºrde ein `AssertionError` ausgegeben werden.
Da das nicht der Fall ist, k√∂nnen wir davon ausgehen, dass unser Algorithmus korrekt arbeitet.

Wir sollten uns aber klar machen, dass wir mit obigem Algorithmus tats√§chlich √Ñpfel und Birnen **zusammengez√§hlt** haben.
Das ist nicht dasselbe wie die beiden Zahlen `3` und `4` zu **addieren** (erstes operiert auf der Anzahl von Objekten, letzteres auf Zahlen).

Trotzdem kommt bei beiden Verfahren das Gleiche heraus: `sieben` = 7 = 4 + 3.\
Wir wollen uns das zunutze machen und auf der Grundlage des bestehenden Algorithmus eine *Rechenvorschrift* f√ºr die [Addition](https://de.wikipedia.org/wiki/Addition) erstellen.

Die Idee ist, anstelle beliebiger Objekte nat√ºrliche Zahlen zu verwenden; auch Mengen von Zahlen k√∂nnen abgez√§hlt werden:

```{julia}
@show count([1, 2, 3, 4])
@show collect(1:7)
@show count(1:7)
@show count(1:100);
```

Ein Ausdruck in der Form `start:stop` erzeugt eine [range](https://docs.julialang.org/en/v1/base/math/#Base.range), ein Julia-Objekt das, wenn es z.B. mit [collect](https://docs.julialang.org/en/v1/base/collections/#Base.collect-Tuple{Any}) ausgewertet wird, einen Vector der Zahlen von `start` bis `stop` erzeugt.

Entscheidend ist hier die Erkenntnis, dass offensichtlich die Anzahl der ersten $n$ nat√ºrlichen Zahlen (ohne die `0`) immer gleich $n$ ist.
Das kann formal so ausgedr√ºckt werden:

$$
N = \{1,2,\dots,n\} \implies |N| = n,
$$

wobei $|N|$ die [M√§chtigkeit](https://de.wikipedia.org/wiki/M%C3%A4chtigkeit_(Mathematik)) der Menge $N$ bezeichnet, also die Anzahl der Elemente in $N$.

Mit Hilfe der *Peano-Axiome* kann gezeigt werden, dass diese Aussage f√ºr jedes $n$ wahr ist.
Wir k√∂nnen also unseren Algorithmus f√ºr die *Addition* so anpassen, dass er anstatt Mengen abzuz√§hlen, direkt mit nat√ºrlichen Zahlen rechnet:

```{julia}
function nat_add(a::Integer, b::Integer)
  if a < 0 || b < 0
    throw(DomainError((a, b), "both arguments must be natural numbers"))
  end
  while b > 0
    a += 1
    b -= 1
  end
  a
end
```

Der Kern unseres Algorithmus bleibt dabei unver√§ndert: `a` wird um `1` erh√∂ht, `b` um `1` verringert, nur dass wir jetzt keinen gesonderten Z√§hler mehr f√ºhren m√ºssen.

::: {.callout-note}
## Datentyp Integer
Beachte, dass es in Julia keinen Datentyp f√ºr nat√ºrliche Zahlen gibt.
Die beiden Parameter `a` und `b` der Funktion `nat_add` sind als `Integer` festgelegt, einem weiteren [abstrakten Datentyp](https://docs.julialang.org/en/v1/manual/types/#man-abstract-types), der es zwar erlaubt, hier beliebige [ganzzahlige Werte](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Integers) zu √ºbergeben, aber grunds√§tzlich auch negative Werte zul√§sst.
:::

Wir m√ºssen also selbst pr√ºfen, ob die der Funktion √ºbergebenen Argumente tats√§chlich nat√ºrliche Zahlen sind.
Der Ausdruck `a < 0 || b < 0` verwendet dazu eine [short-circuit-evaluation](https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation), mit der mehrere Bedinungen gleichzeitig gepr√ºft werden.
Falls eines der beiden Argumente kleiner `0` ist, wird die Abarbeitung mit einem Fehler abgebrochen.

```{julia}
@assert nat_add(4, 0) == 4 + 0
@assert nat_add(0, 3) == 0 + 3
@assert nat_add(4, 3) == 4 + 3
```

F√ºr nat√ºrliche Zahlen funktioniert unser Algorithmus wie erwartet.
Wenn wir aber eine negative ganze Zahl eingeben, dann erhalten wir einen Fehler:

```{julia}
try
  nat_add(17, -4)
catch e
  println(e)
end
```

Und wenn wir versuchen, etwas Anderes als ganze Zahlen zu addieren, bekommen wir ebenfalls einen Fehler:

```{julia}
try
  nat_add(17, 4.5)
catch e
  println(e)
end
```

### Subtraktion

Die [Subtraktion](https://de.wikipedia.org/wiki/Subtraktion) ist die Umkehrung der *Addition*.
Wenn wir unseren Algorithmus f√ºr die Addition nur an einer Stelle √§ndern, k√∂nnen wir damit subtrahieren anstatt addieren: `a` wird in der Schleife jeweils um `1` verringert anstatt erh√∂ht (wir z√§hlen also r√ºckw√§rts anstatt vorw√§rts).

Falls $a < b$ kommt dabei aber ein negatives Ergebnis heraus, was f√ºr nat√ºrliche Zahlen nicht zul√§ssig ist.
Die *Peano-Axiome* sagen, dass die `0` keinen Vorg√§nger hat und damit die kleinste nat√ºrliche Zahl ist.
Wenn wir mit nat√ºrlichen Zahlen rechnen, ist das Ergebnis einer solchen Subtraktion immer gleich `0`:

$$
a < b \implies a - b = 0, \quad a, b \in \mathbb{N}
$$

Wir m√ºssen also in der Schleifenbedingung zus√§tzlich auf `a > 0` pr√ºfen:

```{julia}
function nat_sub(a::Integer, b::Integer)
  if a < 0 || b < 0
    throw(DomainError((a, b), "both arguments must be natural numbers"))
  end
  while a > 0 && b > 0
    a -= 1
    b -= 1
  end
  a
end
```

```{julia}
@assert nat_sub(7, 4) == 7 - 4
@assert nat_sub(4, 0) == 4 - 0
@assert nat_sub(4, 4) == 4 - 4
@assert nat_sub(3, 4) == 0
```

Die Ergebnisse sind korrekt und wir haben die Subtraktion erfolgreich auf "r√ºckw√§rts z√§hlen" zur√ºckgef√ºhrt.

### Multiplikation

Die [Multiplikation](https://de.wikipedia.org/wiki/Multiplikation) zweier nat√ºrlicher Zahlen $a$ und $b$ ist wie folgt definiert:

$$
a \cdot b = \underbrace{b + b + \cdots + b}_\text{a-mal} = p,
$$

wobei $p$ das *Produkt* der Zahlen $a$ und $b$ genannt wird.

Um das Produkt $a \cdot b$ zu berechnen, m√ºssen wir also lediglich *a-mal* `b` addieren: 

```{julia}
function nat_mul(a::Integer, b::Integer)
  if a < 0 || b < 0
    throw(DomainError((a, b), "both arguments must be natural numbers"))
  end
  p = 0
  while a > 0
    p = nat_add(p, b)
    a -= 1
  end
  p
end
```

```{julia}
@assert nat_mul(3, 4) == 3 * 4
@assert nat_mul(1, 7) == 1 * 7
@assert nat_mul(0, 4) == 0 * 4
@assert nat_mul(3, 0) == 3 * 0
```

Damit haben wir die Multiplikation auf die Addition zur√ºckgef√ºhrt.

### Division

Die [Division](https://de.wikipedia.org/wiki/Division_(Mathematik)) ist die Umkehrung der *Multiplikation*.
Wenn zwei nat√ºrliche Zahlen $a$ und $b$ dividiert werden sollen, wenn also $a \div b$ berechnet werden soll, so wird gefragt, wie man die Zahl $a$ als Vielfaches von $b$ darstellen kann:

$$
a = b \cdot q + r, \quad 0 \leq r < q,
$$

wobei $q$ der ganzzahlige *Quotient* der Division ist, und $r$ den *Rest* der Division angibt.
Wenn $r$ gleich `0` ist, wenn sich also kein Rest bei der Division ergibt, dann ist $b$ ein *Teiler* von $a$; man sagt, $b$ teilt $a$ und schreibt $b \mid a$.
Die Division nat√ºrlicher Zahlen wird daher auch [Teilen mit Rest](https://de.wikipedia.org/wiki/Division_mit_Rest) genannt.

Um den Quotienten $q$ zu berechnen, m√ºssen wir feststellen, wie oft $b$ in $a$ "passt", d.h. wie oft $b$ von $a$ abgezogen werden kann.
Das f√ºhrt zu folgendem Algorithmus:

```{julia}
function nat_div(a::Integer, b::Integer)
  if a < 0 || b < 0
    throw(DomainError((a, b), "both arguments must be natural numbers"))
  end
  b == 0 && throw(DomainError(b, "division by 0 is not defined"))
  q = 0
  while a >= b
    a = nat_sub(a, b)
    q += 1
  end
  q
end
```

Wir erkennen hier auch, warum die Division durch `0` nicht erlaubt ist:
wenn `b` gleich `0` ist, dann wird innerhalb der Schleife `a` nicht verringert, und die Schleifenbedingung `a >= b` bleibt immer wahr.
Damit w√ºrde eine [Endlosschleife](https://de.wikipedia.org/wiki/Endlosschleife_(Programmierung)) entstehen, d.h. die Abarbeitung ist nie zuende und der Quotient `q` w√§chst gegen unendlich ($\infty$).

```{julia}
@assert nat_div(12, 4) == 12 √∑ 4
@assert nat_div(13, 4) == 13 √∑ 4
@assert nat_div(3, 4)  == 3 √∑ 4
@assert nat_div(0, 4)  == 0 √∑ 4

try
  nat_div(3, 0)
catch e
  println(e)
end
```

Damit haben wir die Division auf die Subtraktion zur√ºckgef√ºhrt.

### Zusammenfassung

Wir haben unser Ziel, die *Grundrechenarten* in $\mathbb{N}$ auf *einfaches Z√§hlen* zur√ºckzuf√ºhren erreicht.
Nachfolgend eine √úbersicht der Rechenarten und ihrer Operatoren:

| Rechenart      | Symbol  | Julia Operator | Funktion ($\mathbb{N}$)  |
|:---------------|:-------:|:--------------:|:-------------------------|
| Addition       | $+$     | `+`            | `nat_add`                |
| Subtraktion    | $-$     | `-`            | `nat_sub`                |
| Multiplikation | $\cdot$ | `*`            | `nat_mul`                |
| Division       | $\div$  | `√∑`            | `nat_div`                |
: Operatoren der Grundrechenarten {#tbl-operatoren}


## Zahlensysteme

Um effizient mit Zahlen rechnen zu k√∂nnen, m√ºssen wir diese auf geeignete Weise darstellen.
Heute verwenden wir dazu haupts√§chlich das [Dezimalsystem](https://de.wikipedia.org/wiki/Dezimalsystem) und f√ºr Berechnungen mit dem Computer das [Dualsystem](https://de.wikipedia.org/wiki/Dualsystem), auch *Bin√§rsystem* genannt.

Beides sind sogenannte [Stellenwertsysteme](https://de.wikipedia.org/wiki/Stellenwertsystem), bei denen eine Zahl aus verschiedenen [Ziffern](https://de.wikipedia.org/wiki/Zahlzeichen) gebildet wird, deren jeweiliger Beitrag zum Gesamtwert der Zahl von ihrer Position innerhalb der Zahl abh√§ngt.

Daneben gibt es auch (historische) [Additionssysteme](https://de.wikipedia.org/wiki/Additionssystem), bei denen sich der Wert einer Zahl durch Addieren der Werte ihrer Ziffern errechnet.

::: {.callout-note}
## Positions- und Additionssysteme
Bei einem *Positionssystem* (auch *Stellenwertsystem* genannt) ist der Wert einer Ziffer abh√§ngig von der Position dieser Ziffer innerhalb der Zahl.\
Bei *Additionssystemen* ist der Wert einer Ziffer immer gleich und alle Ziffern werden einfach addiert, um den Wert der Zahl festzulegen.
:::

### R√∂mische Zahlen

[R√∂mische Zahlen](https://de.wikipedia.org/wiki/R%C3%B6mische_Zahlschrift) sind ein Beispiel eines Additionssytems.
Die Ziffern sind hier lateinische Gro√übuchstaben, denen ein fester Wert zugewiesen wird:

| Ziffer | I | V | X  | L  | C   | D   | M    |
|--------+---+---+----+----+-----+-----+------|
| Wert   | 1 | 5 | 10 | 50 | 100 | 500 | 1000 |
: R√∂mische Ziffern {#tbl-ziffern}

Da die Werte der Ziffern bei einem Additionssystem einfach zusammengez√§hlt werden, ist z.B. der Wert der r√∂mischen Zahl `XVII` gleich 10 + 5 + 1 + 1 = 17.

::: {.callout-note}
## Subtraktionsregel
Die Subtraktionsregel ist eine √ºbliche, verk√ºrzende Schreibweise, mit der vermieden wird, vier gleiche Ziffern in direkter Aufeinanderfolge zu schreiben.\
Die Subtraktionsregel besagt, dass die Ziffern `I`, `X` und `C` einer ihrer beiden jeweils n√§chstgr√∂√üeren Ziffern vorangestellt werden d√ºrfen und dann in ihrem Zahlwert von deren Wert abzuziehen sind:

- `I` vor `V` oder `X`  =>  `IV` = 4, `IX` = 9
- `X` vor `L` oder `C`  =>  `XL` = 40, `XC` = 90
- `C` vor `D` oder `M`  =>  `CD` = 400, `CM` = 900
:::

::: {.callout-tip}
## Der Wert der r√∂mischen Zahl MCMLXXXIV
`MCMLXXXIV` = $1000+(1000-100)+50+(3\cdot10)+(5-1)=1984$
:::

Das Rechnen mit r√∂mischen Zahlen ist allerdings recht schwierig; hierf√ºr wurden Hilfsmittel wie das [Rechenbrett](https://de.wikipedia.org/wiki/Rechnen_auf_Linien) und der [Abakus](https://de.wikipedia.org/wiki/Abakus_(Rechenhilfsmittel)) verwendet.
Dabei werden die r√∂mischen Zahlen in ein Positionssystem √ºberf√ºhrt und Werten in der Form von Rechenm√ºnzen oder Kugeln zugeordnet, mit denen dann die Rechenoperationen durchgef√ºhrt werden.
Das Rechnen mit Rechenbrett und Abakus war bis zum Ende des Mittelalters weit verbreitet und wurde erst durch die Einf√ºhrung der indischen Zahlenschrift und des heute gebr√§uchlichen Dezimalsystems abgel√∂st.

Wir wollen also nicht direkt mit r√∂mischen Zahlen rechnen, sondern entwickeln eine Funktion, die r√∂mische Zahlen in das Dezimalsystem √ºberf√ºhrt.

Als ersten Schritt definieren wir hierzu ein Objekt vom Datentyp [Dict](https://docs.julialang.org/en/v1/base/collections/#Dictionaries), das den Wert der r√∂mischen Ziffern gem√§√ü @tbl-ziffern festlegt:

```{julia}
keys =   ['I', 'V', 'X', 'L', 'C', 'D', 'M']
values = [1,   5,   10,  50,  100, 500, 1000]
const RD = Dict(zip(keys, values))
```

Jeder Eintrag in einem `Dict` entspricht einem Schl√ºssel-Werte Paar; bei dem gerade angelegten `RD` Objekt ist der Schl√ºssel vom Typ `Char` (ein einzelner Buchstabe) und der Wert vom Typ `Int64` (eine ganzzahlige Dezimalzahl mit einer internen L√§nge von 64 Bit).\
Der Wert f√ºr einen bestimmten Schl√ºssel kann so ausgelesen werden:

```{julia}
RD['D']
```

Damit k√∂nnten wir eine r√∂mische Zahl sehr einfach in eine Dezimalzahl umwandeln: 

```{julia}
function rom2dec(rom::String)::Int
  dec = 0
  for c in rom
    dec += RD[c]
  end
  dec
end

rom2dec("XVII")
```

Allerdings macht die uns die Subtraktionsregel einen Strich durch die Rechnung, da so aufgeschriebene r√∂mische Zahlen nicht korrekt umgewandelt werden:

```{julia}
rom2dec("MCMLXXXIV")
```

Das richtige Ergebnis w√§re `MCMLXXXIV` = 1984, aber das `C` vor dem `M` wurde hinzugez√§hlt anstatt abgezogen und genauso das `I` vor dem `V`.
Das berechnete Ergebnis ist damit um 2 `C` und 2 `I` (= 202) gr√∂√üer als das korrekte Ergebnis.

Im Regelfall werden die r√∂mischen Ziffern in absteigender Folge von links nach rechts aufgeschrieben, d.h. die gr√∂√üte (in die Zahl passende) Ziffer zuerst, dann die n√§chst kleinere und so weiter.

Die Zahl 66 wird zum Beispliel als `LXVI` geschrieben; wenn wir dagegen `XLVI` schreiben, dann taucht die kleinere Ziffer `X` vor der gr√∂√üeren Ziffer `L` auf, und wir m√ºssen die Subtraktionsregel anwenden mit dem Ergebnis 46.

Die Subtraktionsregel muss also immer angewendet werden wenn eine gr√∂√üere auf eine kleinere Ziffer folgt.
Das kann dann so im Programmcode umgesetzt werden:

```julia
function roman2decimal(roman::String)::Int
  decimal = 0
  for i in eachindex(roman)
    current = RD[roman[i]]
    i == lastindex(roman) && return decimal + current
    next = RD[roman[i+1]]
    current < next ? decimal -= current : decimal += current
  end
end
```
Zur Kontrolle rufen wir die entsprechende Funktion aus dem begleitenden Julia-Paket `MatheKapierenMitJulia` auf.
Da die einzelnen Funktionen in Untermodule gegliedert sind, m√ºssen wir den entsprechenden Modulnamen (hier `Zahlentheorie`) beim Aufruf der Funktion ebenfalls angeben:

```{julia}
using MatheKapierenMitJulia

@assert Zahlentheorie.roman2decimal("XVII") == 17
@assert Zahlentheorie.roman2decimal("MCMLXXXIV") == 1984
```



### Dezimalzahlen

### Bin√§rzahlen
